import json
import os
import shutil
from copy import deepcopy
from typing import Any, Dict, Iterable, List, Optional, Set, Union

from loguru import logger
from packman.utils.files import checksum, remove_path
from packman.utils.progress import ProgressCallback, StepProgress, progress_noop
from pydantic import BaseModel, Field


def replace_root_path(*, path: str, new_root_path: str, old_root_path: str) -> str:
    unrooted = os.path.relpath(path, old_root_path)
    result = os.path.normpath(os.path.join(new_root_path, unrooted))
    return result


class BaseModelWithPrivateAttributes(BaseModel):
    def __setattr__(self, name: str, value: Any):
        if name.startswith("_"):
            self.__dict__[name] = value
        else:
            super().__setattr__(name, value)

    def dict(self, *args: Any, **kwargs: Any) -> Dict[str, Any]:
        exclude = kwargs.pop("exclude")
        if exclude:
            exclude = set(exclude)
        else:
            exclude = set()

        for key in self.__dict__:
            if key.startswith("_"):
                exclude.add(key)
        return super().dict(*args, **kwargs, exclude=exclude)

    class Config:
        arbitrary_types_allowed = True


class ManifestPackage(BaseModelWithPrivateAttributes):
    """
    Describes an installed package's files, checksums, files displaced during installation, etc.
    """

    version: Union[str, None] = Field(
        ..., description="Name of the installed package version."
    )
    options: Set[str] = Field(
        ...,
        description="List of specific packages installed for this version"
        " e.g. software often has separate builds for amd64, arm, x86.",
    )
    files: Set[str] = Field(
        ...,
        description="List of files claimed (either partially or wholly) by this package"
        " e.g. files that were created, modified or replaced during the installation of this version.",
    )
    checksums: Dict[str, str] = Field(
        {},
        description="Dictionary mapping files to their checksums for basic conflict detection"
        " and file validation.",
    )

    def __init__(self, **data: Any) -> None:
        super().__init__(**data)
        self._root_path = "."

    def deepcopy(self) -> "ManifestPackage":
        return deepcopy(self)

    def compute_checksums(self) -> None:
        """
        Computes checksums for files that do not already have checksums; does not recompute pre-existing checksums.
        If a file for some reason gets updated, first delete it from the checksum dictionary.
        """
        self.checksums = {}
        for file in self.files:
            if file not in self.checksums:
                self.checksums[file] = checksum(file)

    def update_path_root(self, root_path: str) -> None:
        """
        Updates the paths to be relative to a new root assuming the package's files remain at the same absolute path
        in the file-system.
        """

        new_files: Set[str] = set()
        for file in self.files:
            new_file = replace_root_path(
                path=file, new_root_path=root_path, old_root_path=self._root_path
            )
            new_files.add(new_file)
        self.files = new_files

        new_checksums: Dict[str, str] = {}
        for file, chk in self.checksums.items():
            new_file = replace_root_path(
                path=file, new_root_path=root_path, old_root_path=self._root_path
            )
            new_checksums[new_file] = chk
        self.checksums = new_checksums
        self._root_path = root_path

    def prepend_path(self, path: str) -> None:
        """
        Changes the absolute path of this package's files. Paths will be normalised.
        """
        new_files: Set[str] = set()
        new_checksums: Dict[str, str] = {}
        for file in self.files:
            new_file = os.path.normpath(os.path.join(path, file))
            new_files.add(new_file)
            new_checksums[new_file] = self.checksums[file]
        self.files = new_files
        self.checksums = new_checksums

    class Config:
        title = "Manifest Package"


class Manifest(BaseModelWithPrivateAttributes):
    """
    Describes the packages which have been installed by Packman.
    """

    version = Field(
        1, description="Manifest version for future backwards compatibility."
    )
    packages: Dict[str, ManifestPackage] = Field(
        {}, description="Currently installed packages."
    )
    file_map: Dict[str, List[str]] = Field(
        {},
        description="Files claimed by Packman packages; autogenerated from package file lists.",
    )
    original_files: Dict[str, str] = Field(
        {},
        description="Locations of files backed up during installation of a Packman package.",
    )
    orphaned_files: Set[str] = Field(
        set(),
        description="Locations of files which were previously claimed by Packman but which have been disowned "
        "due to checksum mismatch; autogenerated based on package checksums at manifest save time.",
    )

    _root_path: str
    _file_checksums: Dict[str, Set[str]]

    def __init__(self, **data: Any) -> None:
        super().__init__(**data)
        self._root_path = "."
        self._file_checksums = {}
        self._update_checksum_map()

    @property
    def modified_files(self) -> Iterable[str]:
        return self.file_map.keys()

    def _update_checksum_map(self) -> None:
        for package in self.packages.values():
            for file, chk in package.checksums.items():
                if file in self._file_checksums:
                    self._file_checksums[file].add(chk)
                else:
                    self._file_checksums[file] = set((chk,))

    def deepcopy(self) -> "Manifest":
        return deepcopy(self)

    def add_package(
        self,
        name: str,
        *,
        version: Optional[str] = None,
        options: Iterable[str],
        files: Iterable[str],
    ) -> ManifestPackage:
        package = self.packages[name] = ManifestPackage(
            version=version, options=options, files=files
        )
        package._root_path = self._root_path
        return package

    def cleanup_files(self, remove_orphans: bool = False) -> None:
        """
        Deletes files that have been removed from the manifest since the last cleanup, or since the Manifest was
        instantiated if no previous cleanups.

        Rebuilds file_map and orphaned_files.
        """

        new_file_map: Dict[str, List[str]] = {}
        for name, package in self.packages.items():
            for file in package.files:
                file = os.path.normpath(file)
                if file in self.orphaned_files:
                    self.orphaned_files.remove(file)
                if file not in new_file_map:
                    new_file_map[file] = [name]
                else:
                    new_file_map[file].append(name)

        for file in self.file_map:
            if file not in new_file_map:
                curr_chk = checksum(file)
                if remove_orphans or any(
                    chk == curr_chk for chk in self._file_checksums[file]
                ):
                    logger.debug(f"cleaning up {file}")
                    if file in self.original_files:
                        shutil.copy2(self.original_files[file], file)
                        remove_path(self.original_files[file])
                        del self.original_files[file]
                    else:
                        remove_path(file)
                else:
                    logger.debug(f"found orphan {file}")
                    self.orphaned_files.add(file)
                # TODO fix issue where files are not being recognised as orphan

        if remove_orphans:
            for file in self.orphaned_files:
                logger.debug(f"removing orphan {file}")
                remove_path(self.original_files[file])
            self.orphaned_files.clear()

        self.file_map = new_file_map

    def update_checksums(self) -> None:
        """
        Computes uncomputed package checksums; does not recompute pre-existing checksums.
        """
        for package in self.packages.values():
            package.compute_checksums()
        self._update_checksum_map()

    def write_json(self, path: str) -> None:
        """
        Writes the manifest in JSON format to the given path.

        File paths stored within the manifest will reflect the relative path of the path given.
        """
        path_dir = os.path.normpath(os.path.dirname(path))
        if path_dir != ".":
            os.makedirs(path_dir, exist_ok=True)
        with open(path, "w") as fp:
            if path_dir != ".":
                clone = self.deepcopy()
                clone.update_path_root(".")
                fp.write(clone.json(indent=2))
            else:
                fp.write(self.json(indent=2))

    def update_path_root(self, root_path: str) -> None:
        """
        Updates the paths to be relative to a new root assuming the manifest's files remain at the same absolute path
        in the file-system.
        """

        for package in self.packages.values():
            package.update_path_root(root_path)

        new_file_map: Dict[str, List[str]] = {}
        for file, packages in self.file_map.items():
            new_file = replace_root_path(
                path=file, new_root_path=root_path, old_root_path=self._root_path
            )
            new_file_map[new_file] = packages
        self.file_map = new_file_map

        new_orphaned_files: Set[str] = set()
        for file in self.orphaned_files:
            new_file = replace_root_path(
                path=file, new_root_path=root_path, old_root_path=self._root_path
            )
            new_orphaned_files.add(new_file)
        self.orphaned_files = new_orphaned_files

        new_original_files: Dict[str, str] = {}
        for file, value in self.original_files.items():
            new_file = replace_root_path(
                path=file, new_root_path=root_path, old_root_path=self._root_path
            )
            new_original_files[file] = value
        self.original_files = new_original_files

        self._update_checksum_map()
        self._root_path = root_path

    def update_files(
        self,
        path: str,
        on_progress: ProgressCallback = progress_noop,
        remove_orphans: bool = False,
    ) -> None:
        """
        Updates the manifest file, cleaning up any files no longer in the manifest.
        """

        step_progress = StepProgress.from_step_count(
            step_count=3, on_progress=on_progress
        )
        self.cleanup_files(remove_orphans=remove_orphans)
        step_progress.advance()
        self.update_checksums()
        step_progress.advance()
        self.write_json(path=path)
        step_progress.advance()

    @staticmethod
    def from_json(path: str, update_root: bool = True) -> "Manifest":
        """
        Creates a new instance of a Manifest, loaded from the given path. If the path does not exist, creates an empty
        Manifest.
        """
        try:
            with open(path, "r") as fp:
                raw = json.load(fp)
                manifest = Manifest(**raw)
        except FileNotFoundError:
            manifest = Manifest()

        if update_root:
            path_dir = os.path.dirname(path)
            if os.path.normpath(path_dir) != ".":
                manifest.update_path_root(path_dir)

        return manifest
